%\dg{small intro on the relationship between quality and metadata. The scope is tricky, and so it is the level of granularity}

Software metadata has become a crucial asset for deploying and publishing software, as it describes the key aspects of a software package (e.g., name, license, authors, etc.), aids comparing it against similar efforts and helps users with faceted search. Package managers like Pypi,\footnote{\url{https://pypi.org/}} Maven Central\footnote{\url{https://search.maven.org/}} or CRAN\footnote{\url{https://cran.r-project.org/}} provide ways of gathering metadata using their own metadata representation.

With the increasing adoption of the FAIR principles, using metadata to describe research outcomes is becoming a more common practice, including research software and code. As with package managers, metadata makes it easier for tool registries and aggregators to present research software with common descriptors so they can be indexed and compared. Although metadata on its own does not guaranty quality, some metadata elements align to quality principles (e.g, documentation, licensing, version naming, etc.). 

\subsection{Metadata schemas for Software}

\dg{Daniel is currently working on this section. Mention DOAP, OntoSoft, SWO, etc. Then Codemeta + Bioschemas + Sd. State the initatives adopting them and then SIRS report}~\cite{sirs_2019}

In the case of research software, there are two main metadata schemas agreed and adopted by broad communities. Codemeta \cite{Boettigeral2017} aims at creating a minimal metadata schema for science software and code. It is based on two types from schema.org \cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. It provides a list of metadata attributes to describe software that can be then expressed in XML or JSON. Bioschemas, a collaborative community project aiming at adding structured markup to Life Science websites, provides a profile (i.e., a recommendation of usage created on top of a schema.org type) corresponding to a \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}, based on the schema.org type \href{https://schema.org/SoftwareApplication}{softwareApplication}. Different from Codemeta, Bioschemas preserves the semantic layer from schema.org.

\dg{there are many other vocabularies for describing software. Some extend schema.org and codemeta. Some other profiles model i/o types. Mention them, and mention that codemeta is the current recommendation that has most community support. Repos are adopting such as InvenioRDM, ASCL for interoperating records. DOAP, all the efforts in codemeta, etc.}

\subsection{The FAIR principles for Research Software (FAIR4RS)}

\dg{maybe move this for an annex? I would like to elaborate on the recommendations that are also being pushed by the community. But that the relationship with quality is not always one to one. Also, there are existing recommendations and tools to help assess the fairness. But as for quality, we do this in the next section. Emphasize the importance of FAIR, and how it is shaping part of the EOSC ecosystem.}

The FAIR principles for Research Software are stated in \cite{chue_hong_neil_p_2022_6623556}, they
are reproduced here for reference:

\textbf{F: Software, and its associated metadata, is easy for both humans and machines to find.}

\begin{itemize}
    \item \textbf{F1} - Software is assigned a globally unique and persistent identifier.
    \begin{itemize}
        \item \textbf{F1.1} - Components of the software representing levels of granularity are assigned distinct identifiers.
        \item \textbf{F1.2} - Different versions of the software are assigned distinct identifiers.
    \end{itemize}

    \item \textbf{F2} - Software is described with rich metadata.
    \item \textbf{F3} - Metadata clearly and explicitly include the identifier of the software they describe.
    \item \textbf{F4} - Metadata are FAIR, searchable and indexable.
\end{itemize}

\textbf{A: Software, and its metadata, is retrievable via standardized protocols.}

\begin{itemize}
    \item \textbf{A1} - Software is retrievable by its identifier using a standardized communications protocol.

    \begin{itemize}
        \item \textbf{A1.1} - The protocol is open, free, and universally implementable.
        \item \textbf{A1.2} - The protocol allows for an authentication and authorization procedure, where necessary.
    \end{itemize}

    \item \textbf{A2} - Metadata are accessible, even when the software is no longer available.
\end{itemize}

\textbf{I: Software interoperates with other software by exchanging data and/or metadata, and/or
through interaction via application programming interfaces (APIs), described through
standards.}

\begin{itemize}
    \item \textbf{I1} - Software reads, writes and exchanges data in a way that meets domain-relevant community standards.
    \item \textbf{I2} - Software includes qualified references to other objects.
\end{itemize}

\textbf{R: Software is both usable (can be executed) and reusable (can be understood, modified, built
upon, or incorporated into other software).}

\begin{itemize}
    \item \textbf{R1} - Software is described with a plurality of accurate and relevant attributes.

    \begin{itemize}
        \item \textbf{R1.1} - Software is given a clear and accessible license.
        \item \textbf{R1.2} - Software is associated with detailed provenance.
    \end{itemize}

    \item \textbf{R2} - Software includes qualified references to other software.
    \item \textbf{R3} - Software meets domain-relevant community standards.
\end{itemize}

\subsection{Mapping Quality Attributes to FAIR4RS}

In this subsection, the relation or link between the FAIR4RS principles and the Quality Attributes
show in Appendix \ref{appendix_qa} is represented in the following table:

\textbf{F1} EOSC-SWRelMan-11, EOSC-SWRelMan-25

\textbf{F1.1} EOSC-SWRelMan-05, EOSC-SWRelMan-33

\textbf{F1.2} EOSC-SWRelMan-02, EOSC-SWRelMan-04, EOSC-SWRelMan-09

\textbf{F2} EOSC-SWRelMan-11, EOSC-Qual-24, EOSC-SWRelMan-26, EOSC-SWRelMan-29, EOSC-SWRelMan-30

\textbf{F3} EOSC-SWRelMan-11

\textbf{F4} EOSC-SWRelMan-11


\textbf{A1} maybe EOSC-SWRelMan-01

\textbf{A1.1} maybe EOSC-SWRelMan-01

\textbf{A1.2} EOSC-SWTest-18

\textbf{A2}

\textbf{I1} EOSC-Qual-29

\textbf{I2} maybe EOSC-SWTest-16

\textbf{R1}

\textbf{R1.1} EOSC-SWRelMan-10, EOSC-SWRelMan-34, EOSC-SrvOps-01, EOSC-SrvOps-02

\textbf{R1.2} EOSC-Qual-27, EOSC-SWTest-20

\textbf{R2}

\textbf{R3} EOSC-Qual-29, EOSC-SWRelMan-32

\dg{need justification, and a way of knowing which principle it was. Maybe the justification can be added to the table, while a summary should follow}

\dg{finally, I would like to reflect on: are there principles that maybe should be reported but are not aligned with the quality attributes we identified?}


% \textcolor{red}{DG: To be developed further once the quality metrics and criteria is clear. The scope of this section is not
% defining metadata for software, but stating how capturing these metadata may help addressing some of the quality metrics.
% For example, capturing schema:keywords may help having a complete description (not the greatest example, I know).}
