%\dg{small intro on the relationship between quality and metadata. The scope is tricky, and so it is the level of granularity}

Software metadata has become a crucial asset when deploying and publishing software, as it describes the key aspects of a software package (e.g., name, id, version, license, authors, etc.), aids comparison against similar efforts and helps users with faceted search. Package managers like Pypi,\footnote{\url{https://pypi.org/}} Maven Central\footnote{\url{https://search.maven.org/}} or CRAN\footnote{\url{https://cran.r-project.org/}} provide ways of gathering metadata using their own metadata representation.

With the increasing adoption of the FAIR principles~\cite{wilkinson_fair_2016}, using metadata to describe research outcomes (including research software and code) is becoming a common practice. As with package managers, metadata makes it easier for tool registries and aggregators to present research software with common descriptors so they can be indexed and compared. Although metadata on its own does not guaranty quality, some metadata elements align to quality principles (e.g, documentation, licensing, version naming, etc.). In this section we review common metadata schemas in Section \ref{subsec:schemas}, we discuss the relationship between FAIR and software code quality in Section \ref{subsec:fair4rs}, and map  which quality software quality attributes are most related to FAIR (Section \ref{subsec:fair4rs_fair}).

\subsection{Metadata schemas for Software}\label{subsec:schemas}

A number of schemas, vocabularies and ontologies describe software at different levels of detail. The Description of a Project (DOAP) ontology\footnote{\url{http://usefulinc.com/ns/doap}} proposes metadata terms for capturing software projects, emphasizing how a project itself is managed (issues, bug tracking, wiki discussions, etc.). Other vocabularies such as OntoSoft \cite{gil2016ontosoft} take on a scientist's perspective by capturing software metadata through a series of questions that researchers are familiar with. On a more abstract formalization level, the Core Software Ontology (CSO)\footnote{\url{http://km.aifb.kit.edu/sites/cos/}} specifies terms for describing software and web services by extending the DOLCE upper ontology \cite{gangemi2002sweetening}.

Other schemas have been specialized for a given domamin. For example, the Software Ontology (SWO)\footnote{\url{http://purl.obolibrary.org/obo/swo.owl}} builds on the Open Biomedical Ontologies such as the Basic Formal Ontology \cite{spear2016functions} to describe software. These ontologies describe a thorough taxonomy of input and output types and formats, particular to the biomedical domain.

Finally, other community initiatives have opted for a lightweight approach. Codemeta \cite{Boettigeral2017} aims at creating a minimal metadata schema for research software and code. It is based on two types from schema.org \cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. In addition, the Codemeta initiative has aligned metadata schemas from many software registries and repositories,\footnote{\url{https://codemeta.github.io/crosswalk/}} making it easier to exchange records between them. Codemeta is one of the recommendations from the Scholarly infrastructures for research software~\cite{sirs_2019}, which calls for EU representatives to ``help establish a stable, long-term governance" for the vocabulary. Two different initiatives have already proposed Codemeta extensions to capture the semantics of software tools. The first one is Bioschemas,\footnote{\url{https://bioschemas.org/}} a collaborative community project aiming at adding structured markup to Life Science websites, which provides a profile (i.e., a recommendation of usage created on top of a schema.org type) for describing \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}s. The second one is the Software Description Ontology \cite{garijo2019okg}, which extends Codemeta in with additional metadata fields to capture executable commands, configuration and limitations of a software component. 



%In the case of research software, there are two main metadata schemas agreed and adopted by broad communities. Codemeta \cite{Boettigeral2017} aims at creating a minimal metadata schema for science software and code. It is based on two types from schema.org \cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. It provides a list of metadata attributes to describe software that can be then expressed in XML or JSON. Bioschemas, a collaborative community project aiming at adding structured markup to Life Science websites, provides a profile (i.e., a recommendation of usage created on top of a schema.org type) corresponding to a \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}, based on the schema.org type \href{https://schema.org/SoftwareApplication}{softwareApplication}. %Different from Codemeta, Bioschemas preserves the semantic layer from schema.org.

%\dg{there are many other vocabularies for describing software. Some extend schema.org and codemeta. Some other profiles model i/o types. Mention them, and mention that codemeta is the current recommendation that has most community support. Repos are adopting such as InvenioRDM, ASCL for interoperating records. DOAP, all the efforts in codemeta, etc.}

\subsection{The FAIR principles for Research Software (FAIR4RS)}\label{subsec:fair4rs}

%\dg{maybe move this for an annex? I would like to elaborate on the recommendations that are also being pushed by the community. But that the relationship with quality is not always one to one. Also, there are existing recommendations and tools to help assess the fairness. But as for quality, we do this in the next section. Emphasize the importance of FAIR, and how it is shaping part of the EOSC ecosystem.}

After the FAIR guiding principles for data were proposed \cite{wilkinson_fair_2016}, the scientific community has discussed how to adapt them to different research artefacts. The FAIR Principles for Research Software Working Group\footnote{\url{https://www.rd-alliance.org/groups/fair-research-software-fair4rs-wg}} was created in September 2021 by the Research Data Alliance to adapt the FAIR principles to reseaech software. As a result, \cite{chue_hong_neil_p_2022_6623556} summarizes the community discussion, defining the FAIR4RS principles as follows:

%Since research software and their associated research object (e.g., algorithms, workflows, etc.) is different from a data, and the FAIR principles for Research Software 

\textbf{F: Software, and its associated metadata, is easy for both humans and machines to find.}

\begin{itemize}
    \item \textbf{F1} - Software is assigned a globally unique and persistent identifier.
    \begin{itemize}
        \item \textbf{F1.1} - Components of the software representing levels of granularity are assigned distinct identifiers.
        \item \textbf{F1.2} - Different versions of the software are assigned distinct identifiers.
    \end{itemize}

    \item \textbf{F2} - Software is described with rich metadata.
    \item \textbf{F3} - Metadata clearly and explicitly include the identifier of the software they describe.
    \item \textbf{F4} - Metadata are FAIR, searchable and indexable.
\end{itemize}

\textbf{A: Software, and its metadata, is retrievable via standardized protocols.}

\begin{itemize}
    \item \textbf{A1} - Software is retrievable by its identifier using a standardized communications protocol.

    \begin{itemize}
        \item \textbf{A1.1} - The protocol is open, free, and universally implementable.
        \item \textbf{A1.2} - The protocol allows for an authentication and authorization procedure, where necessary.
    \end{itemize}

    \item \textbf{A2} - Metadata are accessible, even when the software is no longer available.
\end{itemize}

\textbf{I: Software interoperates with other software by exchanging data and/or metadata, and/or
through interaction via application programming interfaces (APIs), described through
standards.}

\begin{itemize}
    \item \textbf{I1} - Software reads, writes and exchanges data in a way that meets domain-relevant community standards.
    \item \textbf{I2} - Software includes qualified references to other objects.
\end{itemize}

\textbf{R: Software is both usable (can be executed) and reusable (can be understood, modified, built
upon, or incorporated into other software).}

\begin{itemize}
    \item \textbf{R1} - Software is described with a plurality of accurate and relevant attributes.

    \begin{itemize}
        \item \textbf{R1.1} - Software is given a clear and accessible license.
        \item \textbf{R1.2} - Software is associated with detailed provenance.
    \end{itemize}

    \item \textbf{R2} - Software includes qualified references to other software.
    \item \textbf{R3} - Software meets domain-relevant community standards.
\end{itemize}

\subsection{Mapping Quality Attributes to FAIR4RS}\label{subsec:fair4rs_fair}

\dg{Daniel will finish this section on 30 nov. Also put which codemeta properties may help address the quality attribute}
In this subsection, the relation or link between the FAIR4RS principles and the Quality Attributes
show in Appendix \ref{appendix_qa} is represented in the following table:

\textbf{F1} EOSC-SWRelMan-11, EOSC-SWRelMan-25

\textbf{F1.1} EOSC-SWRelMan-05, EOSC-SWRelMan-33

\textbf{F1.2} EOSC-SWRelMan-02, EOSC-SWRelMan-04, EOSC-SWRelMan-09

\textbf{F2} EOSC-SWRelMan-11, EOSC-Qual-24, EOSC-SWRelMan-26, EOSC-SWRelMan-29, EOSC-SWRelMan-30

\textbf{F3} EOSC-SWRelMan-11

\textbf{F4} EOSC-SWRelMan-11


\textbf{A1} maybe EOSC-SWRelMan-01

\textbf{A1.1} maybe EOSC-SWRelMan-01

\textbf{A1.2} EOSC-SWTest-18

\textbf{A2}

\textbf{I1} EOSC-Qual-29

\textbf{I2} maybe EOSC-SWTest-16

\textbf{R1}

\textbf{R1.1} EOSC-SWRelMan-10, EOSC-SWRelMan-34, EOSC-SrvOps-01, EOSC-SrvOps-02

\textbf{R1.2} EOSC-Qual-27, EOSC-SWTest-20

\textbf{R2}

\textbf{R3} EOSC-Qual-29, EOSC-SWRelMan-32

\dg{need justification, and a way of knowing which principle it was. Maybe the justification can be added to the table, while a summary should follow}

\dg{finally, I would like to reflect on: are there principles that maybe should be reported but are not aligned with the quality attributes we identified?}


% \textcolor{red}{DG: To be developed further once the quality metrics and criteria is clear. The scope of this section is not
% defining metadata for software, but stating how capturing these metadata may help addressing some of the quality metrics.
% For example, capturing schema:keywords may help having a complete description (not the greatest example, I know).}
