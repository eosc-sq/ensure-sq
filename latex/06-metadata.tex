Software metadata has become a crucial asset when deploying and publishing software, as it describes the key aspects of a software package (e.g. the name, id, version, license, authors, etc.), aiding comparison against similar efforts and helping users with faceted search. Package managers such as PyPI,\footnote{\url{https://pypi.org/}} Maven Central\footnote{\url{https://search.maven.org/}} or CRAN\footnote{\url{https://cran.r-project.org/}} provide ways of gathering metadata using their own  representation.

With the increasing adoption of the FAIR principles~\cite{wilkinson_fair_2016}, using metadata to describe research outcomes (including Research Software and code) is becoming a common practice. As with package managers, metadata make it easier for tool registries and aggregators to present Research Software with common descriptors that can be indexed and compared. Although metadata on their own does not guaranty quality, some metadata elements align to quality principles (e.g, documentation, licensing, version naming, etc.).

In Section~\ref{subsec:schemas} we review common metadata schemas. In Section~\ref{subsec:fair4rs}, we discuss the relationship between FAIR and software code quality. Finally, in Section \ref{subsec:fair4rs_fair}, we map some of the Software Quality Attributes with closely related FAIR principles for Research Software (FAIR4RS).

\subsection{Metadata schemas for Software}
\label{subsec:schemas}

A number of schemas, vocabularies and ontologies describe software at different levels of detail. The Description of a Project (DOAP) ontology\footnote{\url{http://usefulinc.com/ns/doap}} proposes metadata terms for capturing software projects, emphasizing how a project itself is managed (issues, bug tracking, wiki discussions, etc.). Other vocabularies such as OntoSoft \cite{gil2016ontosoft} take on a scientist's perspective by capturing software metadata through a series of questions that researchers are familiar with. On a more abstract formalization level, the Core Software Ontology (CSO)\footnote{\url{http://km.aifb.kit.edu/sites/cos/}} specifies terms for describing software and web services by extending the DOLCE upper ontology \cite{gangemi2002sweetening}.

Other schemas have been specialized for a given domain. For example, the Software Ontology (SWO)\footnote{\url{http://purl.obolibrary.org/obo/swo.owl}} builds on the Open Biomedical Ontologies such as the Basic Formal Ontology \cite{spear2016functions} to describe software. These ontologies describe a thorough taxonomy of input and output types and formats, particular to the biomedical domain.

Finally, other community initiatives have opted for a lightweight approach. Codemeta~\cite{Boettigeral2017} aims at creating a minimal metadata schema for Research Software and code. It is based on two types from \url{https://schema.org}~\cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. In addition, the Codemeta initiative has aligned metadata schemas from many software registries and repositories\footnote{\url{https://codemeta.github.io/crosswalk/}} making it easier to exchange records between them. Codemeta is one of the recommendations from the Scholarly infrastructures for Research Software~\cite{sirs_2019}, which calls for EU representatives to ``help establish a stable, long-term governance'' for the vocabulary. Two different initiatives have already proposed Codemeta extensions to capture the semantics of software tools. The first one is Bioschemas\footnote{\url{https://bioschemas.org/}}, a collaborative community project aiming at adding structured markup to Life Science websites, which provides a profile (i.e., a recommendation of usage created on top of a schema.org type) for describing \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}s. The second one is the Software Description Ontology \cite{garijo2019okg}, which extends Codemeta with additional metadata fields to capture executable commands, configuration and limitations of a software component. 

%\dg{there are many other vocabularies for describing software. Some extend schema.org and codemeta. Some other profiles model i/o types. Mention them, and mention that codemeta is the current recommendation that has most community support. Repos are adopting such as InvenioRDM, ASCL for interoperating records. DOAP, all the efforts in codemeta, etc.}

\subsection{The FAIR principles for Research Software (FAIR4RS)}
\label{subsec:fair4rs}

%\dg{maybe move this for an annex? I would like to elaborate on the recommendations that are also being pushed by the community. But that the relationship with quality is not always one to one. Also, there are existing recommendations and tools to help assess the fairness. But as for quality, we do this in the next section. Emphasize the importance of FAIR, and how it is shaping part of the EOSC ecosystem.}

After the FAIR guiding principles for data were proposed \cite{wilkinson_fair_2016}, the scientific community discussed how to adapt them to different research artefacts. The FAIR Principles for Research Software Working Group\footnote{\url{https://www.rd-alliance.org/groups/fair-research-software-fair4rs-wg}} was created in September 2021 by the Research Data Alliance to adapt the FAIR principles to Research Software. As a result \cite{chue_hong_neil_p_2022_6623556} summarizes the community discussion, defining the FAIR4RS principles as follows:

\textbf{F: Software, and its associated metadata, is easy for both humans and machines to find.}

\begin{itemize}
    \item \textbf{F1} - Software is assigned a globally unique and persistent identifier.
    \begin{itemize}
        \item \textbf{F1.1} - Components of the software representing levels of granularity are assigned distinct identifiers.
        \item \textbf{F1.2} - Different versions of the software are assigned distinct identifiers.
    \end{itemize}

    \item \textbf{F2} - Software is described with rich metadata.
    \item \textbf{F3} - Metadata clearly and explicitly include the identifier of the software they describe.
    \item \textbf{F4} - Metadata are FAIR, searchable and indexable.
\end{itemize}

\textbf{A: Software, and its metadata, is retrievable via standardized protocols.}

\begin{itemize}
    \item \textbf{A1} - Software is retrievable by its identifier using a standardized communications protocol.

    \begin{itemize}
        \item \textbf{A1.1} - The protocol is open, free, and universally implementable.
        \item \textbf{A1.2} - The protocol allows for an authentication and authorization procedure, where necessary.
    \end{itemize}

    \item \textbf{A2} - Metadata are accessible, even when the software is no longer available.
\end{itemize}

\textbf{I: Software interoperates with other software by exchanging data and/or metadata, and/or
through interaction via application programming interfaces (APIs), described through
standards.}

\begin{itemize}
    \item \textbf{I1} - Software reads, writes and exchanges data in a way that meets domain-relevant community standards.
    \item \textbf{I2} - Software includes qualified references to other objects.
\end{itemize}

\textbf{R: Software is both usable (can be executed) and reusable (can be understood, modified, built
upon, or incorporated into other software).}

\begin{itemize}
    \item \textbf{R1} - Software is described with a plurality of accurate and relevant attributes.

    \begin{itemize}
        \item \textbf{R1.1} - Software is given a clear and accessible license.
        \item \textbf{R1.2} - Software is associated with detailed provenance.
    \end{itemize}

    \item \textbf{R2} - Software includes qualified references to other software.
    \item \textbf{R3} - Software meets domain-relevant community standards.
\end{itemize}

\subsection{Mapping Quality Attributes to FAIR4RS}\label{subsec:fair4rs_fair}

Many of the FAIR4RS principles described in Section \ref{subsec:fair4rs}  are tightly coupled with good practices for quality software and code. Table \ref{tab:cfs} aligns each of the FAIR4RS principles with the Software Quality Attributes shown in Appendix \ref{appendix_qa}. For each alignment we provide a brief explanation justifying the rationale of our decision. 

%, suggesting which metadata fields from Codemeta (if any) may be relevant for addressing that quality attribute. 
%In this subsection, the relation or link between the FAIR4RS principles and the Quality Attributes
%show in Appendix \ref{appendix_qa} is represented in the following table:

\begin{table}[ht]
\centering
\scriptsize
  \begin{tabular}{|p{0.1\linewidth}|p{0.15\linewidth}|p{0.65\linewidth}|} \hline

    \textbf{FAIR4RS  principle} & \textbf{Quality Attribute} & \textbf{Rationale} \\ \hline

    F1 & \makecell{EOSC-SWRelMan-11 \\ EOSC-SWRelMan-13 \\ EOSC-SWRelMan-25} &
    A codemeta file with metadata of a software component should be appropriately identified and tied to its corresponding software project. A software project package should be uploaded to a public registry. The Codemetadata file should contain the software identifier and its corresponding version Checksums must be used to identify each software binary file uniquely. \\ \hline

    F1.1 & \makecell{EOSC-SWRelMan-05 \\ EOSC-SWRelMan-33} &
    Different branches should be used to address code changes with different scope. Each branch should be identified uniquely within a code repository. The documentation associated to a project must have a persistent identifier. \\ \hline

    F1.2 & \makecell{EOSC-SWRelMan-02 \\ EOSC-SWRelMan-04 \\ EOSC-SWRelMan-06 \\ EOSC-SWRelMan-09} &
    A version control system should exist for the software project code, with a main identified branch where new features are merged. A strategy for transitioning between version releases should be in place. Semantic versioning should be used to uniquely define each code release. \\ \hline

    F2 & \makecell{EOSC-SWRelMan-11 \\ EOSC-SWRelMan-26 \\ EOSC-SWRelMan-29 \\ EOSC-SWRelMan-30 \\ EOSC-SWRelMan-31 \\ EOSC-SWRelMan-32 \\ EOSC-Qual-24} &
    The software project should contain enough information for a reader to verify its objectives. A Codemeta file or citation file formal file should describe relevant project metadata. Documentation should be used to describe the Research Software component, using version control to track differences between software versions. A README file should be provided describing the project with metadata in a human-readable format (e.g., installation instructions, authors, citation, etc.). \\ \hline

    F3 & EOSC-SWRelMan-11 & A Codemeta file should contain an identifier of the software project it describes. \\ \hline
    F4 & EOSC-SWRelMan-11 & A Codemeta file should be provided to facilitate metadata propagation when releasing code (e.g. storing the code in Zenodo). \\ \hline
    A1 & & \\ \hline
    A1.1 & EOSC-SWRelMan-01 & The software project should be publicly available online. \\ \hline
    A1.2 & EOSC-SWTest-18 & An authentication mechanism should be enabled for the target service. \\ \hline
    A2 & & \\ \hline
    I1 & \makecell{EOSC-Qual-29 \\ EOSC-SWTest-01} &
    The software component should comply with internationally recognized standards. Code should follow standard best practices. \\ \hline

    I2 & & \\ \hline
    R1 & \makecell{EOSC-SWRelMan-11 \\ EOSC-SWRelMan-29} &
    A Codemeta file and documentation should describe the software project with accurate, relevant attributes. \\ \hline

    R1.1 & \makecell{EOSC-SWRelMan-10 \\ EOSC-SWRelMan-34 \\ EOSC-SrvOps-01 \\ EOSC-SrvOps-02} &
    A license should be associated with the software project, especially if the project is open source. The documentation of a software project should also provide a license. In case a service is deployed, an ``Acceptable Usage Policy'' and ``Terms of Use'' policy should be clearly defined. \\ \hline

    R1.2 & \makecell{EOSC-SWRelMan-29 \\ EOSC-SWRelMan-30} &
    Software documentation should motivate the rationale and organizations behind the development of a software project, as well as related initiatives that may have  been derived from. \\ \hline

    R2 & \makecell{EOSC-SWTest-25 \\ EOSC-SWRelMan-12} &
    Third party dependencies should be documented and checked for security flaws. A software project should be adequately packaged and installed, containing all the third party dependencies needed for doing so. \\ \hline

    R3 & \makecell{EOSC-Qual-29 \\ EOSC-SWRelMan-32} &
    A software project should comply with internationally adopted standards. Project documentation should be adapted to the domain-relevant community. \\ \hline

  \end{tabular}
\caption{Mapping FAIR4RS to software quality attributes}
\label{tab:cfs}
\end{table}

%\textbf{F1} EOSC-SWRelMan-11, EOSC-SWRelMan-25

%\textbf{F1.1} EOSC-SWRelMan-05, EOSC-SWRelMan-33

%\textbf{F1.2} EOSC-SWRelMan-02, EOSC-SWRelMan-04, EOSC-SWRelMan-09

%\textbf{F2} EOSC-SWRelMan-11, EOSC-Qual-24, EOSC-SWRelMan-26, EOSC-SWRelMan-29, EOSC-SWRelMan-30

%\textbf{F3} EOSC-SWRelMan-11

%\textbf{F4} EOSC-SWRelMan-11


%\textbf{A1} maybe EOSC-SWRelMan-01

%\textbf{A1.1} maybe EOSC-SWRelMan-01

%\textbf{A1.2} EOSC-SWTest-18

%\textbf{A2}

%\textbf{I1} EOSC-Qual-29

%\textbf{I2} maybe EOSC-SWTest-16

%\textbf{R1}

%\textbf{R1.1} EOSC-SWRelMan-10, EOSC-SWRelMan-34, EOSC-SrvOps-01, EOSC-SrvOps-02

%\textbf{R1.2} EOSC-Qual-27, EOSC-SWTest-20

%\textbf{R2}

%\textbf{R3} EOSC-Qual-29, EOSC-SWRelMan-32

