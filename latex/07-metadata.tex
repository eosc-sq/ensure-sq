%\dg{small intro on the relationship between quality and metadata. The scope is tricky, and so it is the level of granularity}

Software metadata has become a crucial asset when deploying and publishing software, as it describes the key aspects of a software package (e.g. the name, id, version, license, authors, etc.), aids comparison against similar efforts and helps users with faceted search. Package managers like Pypi,\footnote{\url{https://pypi.org/}} Maven Central\footnote{\url{https://search.maven.org/}} or CRAN\footnote{\url{https://cran.r-project.org/}} provide ways of gathering metadata using their own metadata representation.

With the increasing adoption of the FAIR principles~\cite{wilkinson_fair_2016}, using metadata to describe research outcomes (including research software and code) is becoming a common practice. As with package managers, metadata make it easier for tool registries and aggregators to present research software with common descriptors so they can be indexed and compared. Although metadata on their own does not guaranty quality, some metadata elements align to quality principles (e.g, documentation, licensing, version naming, etc.). In this section we review common metadata schemas in Section \ref{subsec:schemas}, we discuss the relationship between FAIR and software code quality in Section \ref{subsec:fair4rs}, and map which quality software quality attributes are most closely related to FAIR (Section \ref{subsec:fair4rs_fair}).

\subsection{Metadata schemas for Software}
\label{subsec:schemas}

A number of schemas, vocabularies and ontologies describe software at different levels of detail. The Description of a Project (DOAP) ontology\footnote{\url{http://usefulinc.com/ns/doap}} proposes metadata terms for capturing software projects, emphasizing how a project itself is managed (issues, bug tracking, wiki discussions, etc.). Other vocabularies such as OntoSoft \cite{gil2016ontosoft} take on a scientist's perspective by capturing software metadata through a series of questions that researchers are familiar with. On a more abstract formalization level, the Core Software Ontology (CSO)\footnote{\url{http://km.aifb.kit.edu/sites/cos/}} specifies terms for describing software and web services by extending the DOLCE upper ontology \cite{gangemi2002sweetening}.

Other schemas have been specialized for a given domamin. For example, the Software Ontology (SWO)\footnote{\url{http://purl.obolibrary.org/obo/swo.owl}} builds on the Open Biomedical Ontologies such as the Basic Formal Ontology \cite{spear2016functions} to describe software. These ontologies describe a thorough taxonomy of input and output types and formats, particular to the biomedical domain.

Finally, other community initiatives have opted for a lightweight approach. Codemeta \cite{Boettigeral2017} aims at creating a minimal metadata schema for research software and code. It is based on two types from schema.org \cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. In addition, the Codemeta initiative has aligned metadata schemas from many software registries and repositories,\footnote{\url{https://codemeta.github.io/crosswalk/}} making it easier to exchange records between them. Codemeta is one of the recommendations from the Scholarly infrastructures for research software~\cite{sirs_2019}, which calls for EU representatives to ``help establish a stable, long-term governance" for the vocabulary. Two different initiatives have already proposed Codemeta extensions to capture the semantics of software tools. The first one is Bioschemas,\footnote{\url{https://bioschemas.org/}} a collaborative community project aiming at adding structured markup to Life Science websites, which provides a profile (i.e., a recommendation of usage created on top of a schema.org type) for describing \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}s. The second one is the Software Description Ontology \cite{garijo2019okg}, which extends Codemeta with additional metadata fields to capture executable commands, configuration and limitations of a software component. 



%In the case of research software, there are two main metadata schemas agreed and adopted by broad communities. Codemeta \cite{Boettigeral2017} aims at creating a minimal metadata schema for science software and code. It is based on two types from schema.org \cite{guha_schemaorg_2016}, namely \href{https://schema.org/SoftwareSourceCode}{SoftwareSourceCode} and \href{https://schema.org/SoftwareApplication}{softwareApplication}. It provides a list of metadata attributes to describe software that can be then expressed in XML or JSON. Bioschemas, a collaborative community project aiming at adding structured markup to Life Science websites, provides a profile (i.e., a recommendation of usage created on top of a schema.org type) corresponding to a \href{https://bioschemas.org/profiles/ComputationalTool}{ComputationalTool}, based on the schema.org type \href{https://schema.org/SoftwareApplication}{softwareApplication}. %Different from Codemeta, Bioschemas preserves the semantic layer from schema.org.

%\dg{there are many other vocabularies for describing software. Some extend schema.org and codemeta. Some other profiles model i/o types. Mention them, and mention that codemeta is the current recommendation that has most community support. Repos are adopting such as InvenioRDM, ASCL for interoperating records. DOAP, all the efforts in codemeta, etc.}

\subsection{The FAIR principles for Research Software (FAIR4RS)}\label{subsec:fair4rs}

%\dg{maybe move this for an annex? I would like to elaborate on the recommendations that are also being pushed by the community. But that the relationship with quality is not always one to one. Also, there are existing recommendations and tools to help assess the fairness. But as for quality, we do this in the next section. Emphasize the importance of FAIR, and how it is shaping part of the EOSC ecosystem.}

After the FAIR guiding principles for data were proposed \cite{wilkinson_fair_2016}, the scientific community discussed how to adapt them to different research artefacts. The FAIR Principles for Research Software Working Group\footnote{\url{https://www.rd-alliance.org/groups/fair-research-software-fair4rs-wg}} was created in September 2021 by the Research Data Alliance to adapt the FAIR principles to research software. As a result, \cite{chue_hong_neil_p_2022_6623556} summarizes the community discussion, defining the FAIR4RS principles as follows:

%Since research software and their associated research object (e.g., algorithms, workflows, etc.) is different from a data, and the FAIR principles for Research Software 

\textbf{F: Software, and its associated metadata, is easy for both humans and machines to find.}

\begin{itemize}
    \item \textbf{F1} - Software is assigned a globally unique and persistent identifier.
    \begin{itemize}
        \item \textbf{F1.1} - Components of the software representing levels of granularity are assigned distinct identifiers.
        \item \textbf{F1.2} - Different versions of the software are assigned distinct identifiers.
    \end{itemize}

    \item \textbf{F2} - Software is described with rich metadata.
    \item \textbf{F3} - Metadata clearly and explicitly include the identifier of the software they describe.
    \item \textbf{F4} - Metadata are FAIR, searchable and indexable.
\end{itemize}

\textbf{A: Software, and its metadata, is retrievable via standardized protocols.}

\begin{itemize}
    \item \textbf{A1} - Software is retrievable by its identifier using a standardized communications protocol.

    \begin{itemize}
        \item \textbf{A1.1} - The protocol is open, free, and universally implementable.
        \item \textbf{A1.2} - The protocol allows for an authentication and authorization procedure, where necessary.
    \end{itemize}

    \item \textbf{A2} - Metadata are accessible, even when the software is no longer available.
\end{itemize}

\textbf{I: Software interoperates with other software by exchanging data and/or metadata, and/or
through interaction via application programming interfaces (APIs), described through
standards.}

\begin{itemize}
    \item \textbf{I1} - Software reads, writes and exchanges data in a way that meets domain-relevant community standards.
    \item \textbf{I2} - Software includes qualified references to other objects.
\end{itemize}

\textbf{R: Software is both usable (can be executed) and reusable (can be understood, modified, built
upon, or incorporated into other software).}

\begin{itemize}
    \item \textbf{R1} - Software is described with a plurality of accurate and relevant attributes.

    \begin{itemize}
        \item \textbf{R1.1} - Software is given a clear and accessible license.
        \item \textbf{R1.2} - Software is associated with detailed provenance.
    \end{itemize}

    \item \textbf{R2} - Software includes qualified references to other software.
    \item \textbf{R3} - Software meets domain-relevant community standards.
\end{itemize}

\subsection{Mapping Quality Attributes to FAIR4RS}\label{subsec:fair4rs_fair}

Many of the FAIR4RS principles described in Section \ref{subsec:fair4rs}  are tightly coupled with good practices for quality software and code. Table \ref{tab:cfs} aligns each of the FAIR4RS principles with  the quality attribute from show in Appendix \ref{appendix_qa}. For each alignment we provide a brief explanation justifying the rationale of our decision. 

%, suggesting which metadata fields from Codemeta (if any) may be relevant for addressing that quality attribute. 


%In this subsection, the relation or link between the FAIR4RS principles and the Quality Attributes
%show in Appendix \ref{appendix_qa} is represented in the following table:
\begin{table}[]
\footnotesize
\begin{tabular}{|l|l|l|}
\hline
\textbf{\begin{tabular}[c]{@{}l@{}}FAIR4RS\\  principle\end{tabular}} &
  \textbf{\begin{tabular}[c]{@{}l@{}}Quality \\ Attribute\end{tabular}} &
  \textbf{Rationale} \\ \hline
F1 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-11,\\ EOSC-SWRelMan-13, \\ EOSC-SWRelMan-25,\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}A codemeta file with metadata of a software component should be \\ appropriately identified and tied to its corresponding software project.\\ A software project package should be uploaded to a public registry. \\ The Codemetadata file should contain the software identifier and its \\ corresponding version \\ Checksums must be used to identify each software binary file uniquely\end{tabular} \\ \hline
F1.1 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-05, \\ EOSC-SWRelMan-33\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Different branches should be used to address code changes with \\ different scope. \\ Each branch should be identified uniquely within a code repository. \\ The documentation associated to a project must have a persistent \\ identifier\end{tabular} \\ \hline
F1.2 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-02, \\ EOSC-SWRelMan-04,\\ EOSC-SWRelMan-06, \\ EOSC-SWRelMan-09\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}A version control system should exist for the software project code, \\ with a main identified branch where new features are merged. \\ A strategy for transitioning between version releases should be \\ in place.\\ Semantic versioning should be used to uniquely define each \\ code release.\end{tabular} \\ \hline
F2 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-11,\\ EOSC-SWRelMan-26, \\ EOSC-SWRelMan-29, \\ EOSC-SWRelMan-30,\\ EOSC-SWRelMan-31,\\ EOSC-SWRelMan-32,\\ EOSC-Qual-24\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}The software project should contain enough information for a reader \\ to verify its objectives. A Codemeta file or citation file formal file \\ should describe relevant project metadata.\\ Documentation should be used to describe the research software \\ component, using version control to track differences between \\ software versions. \\ A README file should be provided describing the project with \\ metadata in a human-readable format (e.g., installation instructions, \\ authors, citation, etc.)\end{tabular} \\ \hline
F3 &
  EOSC-SWRelMan-11 &
  \begin{tabular}[c]{@{}l@{}}A Codemeta file should contain an identifier of the software project \\ it describes\end{tabular} \\ \hline
F4 &
  EOSC-SWRelMan-11 &
  \begin{tabular}[c]{@{}l@{}}A Codemeta file should be provided to facilitate metadata \\ propagation when releasing code (e.g., storing the code \\ in Zenodo)\end{tabular} \\ \hline
A1 &
  EOSC-SWRelMan-01 &
  The software project should be publicly available online \\ \hline
A1.1 &
  EOSC-SWRelMan-01 &
  The software project should be publicly available online \\ \hline
A1.2 &
  EOSC-SWTest-18 &
  \begin{tabular}[c]{@{}l@{}}An authentication mechanism should be enabled for the \\ target service\end{tabular} \\ \hline
A2 &
   &
   \\ \hline
I1 &
  \begin{tabular}[c]{@{}l@{}}EOSC-Qual-29\\ EOSC-SWTest-01\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}The software component should comply with internationally \\ recognized standards.\\ Code should follows standard best practices\end{tabular} \\ \hline
I2 &
   &
   \\ \hline
R1 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-11,\\ EOSC-SWRelMan-29\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}A Codemeta file and documentation should describe the software \\ project with accurate, relevant attributes\end{tabular} \\ \hline
R1.1 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-10, \\ EOSC-SWRelMan-34, \\ EOSC-SrvOps-01, \\ EOSC-SrvOps-02\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}A license should be associated with the software project, \\ especially if the project is open source. The documentation of a \\ software project should also  provide a license.\\ In case a service is deployed, an acceptable usage policy and a\\  terms of use policy should be clearly defined\end{tabular} \\ \hline
R1.2 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWRelMan-29,\\ EOSC-SWRelMan-30\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Software documentation should motivate the rationale and \\ organizations behind the development of a software project, \\ as well as related initiatives it may have  been derived from.\end{tabular} \\ \hline
R2 &
  \begin{tabular}[c]{@{}l@{}}EOSC-SWTest-25\\ EOSC-SWRelMan-12\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}Third party dependencies should be documented and checked \\ for security flaws.\\ A software project should be adequately packaged and installed, \\ containing all the third party dependencies needed for doing so.\end{tabular} \\ \hline
R3 &
  \begin{tabular}[c]{@{}l@{}}EOSC-Qual-29, \\ EOSC-SWRelMan-32\end{tabular} &
  \begin{tabular}[c]{@{}l@{}}A software project should comply with internationally adopted \\ standards. \\ Project documentation should be adapted to the domain-relevant\\ community.\end{tabular} \\ \hline
\end{tabular}
\caption{Mapping FAIR4RS to software quality attributes}
\label{tab:cfs}
\end{table}

%\textbf{F1} EOSC-SWRelMan-11, EOSC-SWRelMan-25

%\textbf{F1.1} EOSC-SWRelMan-05, EOSC-SWRelMan-33

%\textbf{F1.2} EOSC-SWRelMan-02, EOSC-SWRelMan-04, EOSC-SWRelMan-09

%\textbf{F2} EOSC-SWRelMan-11, EOSC-Qual-24, EOSC-SWRelMan-26, EOSC-SWRelMan-29, EOSC-SWRelMan-30

%\textbf{F3} EOSC-SWRelMan-11

%\textbf{F4} EOSC-SWRelMan-11


%\textbf{A1} maybe EOSC-SWRelMan-01

%\textbf{A1.1} maybe EOSC-SWRelMan-01

%\textbf{A1.2} EOSC-SWTest-18

%\textbf{A2}

%\textbf{I1} EOSC-Qual-29

%\textbf{I2} maybe EOSC-SWTest-16

%\textbf{R1}

%\textbf{R1.1} EOSC-SWRelMan-10, EOSC-SWRelMan-34, EOSC-SrvOps-01, EOSC-SrvOps-02

%\textbf{R1.2} EOSC-Qual-27, EOSC-SWTest-20

%\textbf{R2}

%\textbf{R3} EOSC-Qual-29, EOSC-SWRelMan-32

